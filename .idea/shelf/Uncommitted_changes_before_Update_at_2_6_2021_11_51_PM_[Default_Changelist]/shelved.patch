Index: blockchain_1/src/User.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.lang.invoke.WrongMethodTypeException;\r\nimport java.security.KeyPair;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.security.PrivateKey;\r\nimport java.security.PublicKey;\r\nimport java.util.*;\r\n\r\nimport static java.util.stream.Collectors.toMap;\r\n\r\npublic class User {\r\n    public PublicKey publicKey;\r\n    private final PrivateKey privateKey;\r\n    public BlockChain blockchain;\r\n    public HashSet<User> users;\r\n\r\n\r\n    public User() throws Exception {\r\n        //Key pair for the user\r\n        KeyPair kp = RSA.generateKeyPair();\r\n        this.publicKey = kp.getPublic();\r\n        this.privateKey = kp.getPrivate();\r\n        this.users = new HashSet<>();\r\n//        setBlockchain();\r\n        updateBlockChainLocal();\r\n    }\r\n\r\n    public void setUsers(HashSet<User> users) {\r\n        this.users = users;\r\n    }\r\n\r\n    public HashSet<User> getUsers() {\r\n        return users;\r\n    }\r\n\r\n\r\n    //    public void updateBlockChain() {\r\n//        this.blockchain = WebMock.updateBlockChain(this);\r\n//    }\r\n\r\n    public void newTransaction(PublicKey publicKeySender, PublicKey publicKeyReceiver, double amount) throws Exception {\r\n        Transaction t = new Transaction(amount, publicKeySender, publicKeyReceiver);\r\n        String key = signTransaction(t);\r\n        //getLastBlock().token.transactions.put(key, t);\r\n        //update blockchin kaj site\r\n        DataHolder.users.forEach(x-> {\r\n            try {\r\n                x.blockchain.addTransaction(t);\r\n            } catch (NoSuchAlgorithmException e) {\r\n                e.printStackTrace();\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    public void newCoinbase(double amount, PublicKey publicKey) {\r\n        getLastBlock().coinbase.newCoinbase(publicKey, amount);\r\n    }\r\n\r\n    //get the blockchain present in most users\r\n/*    public void setBlockchain() {\r\n        HashMap<BlockChain, Integer> voting = new HashMap<>();\r\n        for (User u : users) {\r\n            //if the blockchain is already in the map just increment the count\r\n            if (voting.computeIfPresent(u.blockchain, (key, val) -> val + 1) == null)\r\n                voting.put(u.blockchain, 1);\r\n        }\r\n        //get the blockchain with the most votes\r\n        Optional<Map.Entry<BlockChain, Integer>> tmp = voting.entrySet().stream().max(Map.Entry.comparingByValue());\r\n        if (tmp.isEmpty())\r\n            this.blockchain = new BlockChain();\r\n        else {\r\n            this.blockchain = tmp.get().getKey();\r\n        }\r\n\r\n    }*/\r\n\r\n    public void updateBlockChainLocal(){\r\n        this.blockchain=updateBlockChain();\r\n    }\r\n\r\n    public BlockChain updateBlockChain() {\r\n        //ako ova raboti dzver\r\n        HashMap<BlockChain, Integer> finalBlockChain = new HashMap<>();\r\n        for(User u : users){\r\n            if(finalBlockChain.containsKey(u.blockchain))\r\n                finalBlockChain.put(u.blockchain, finalBlockChain.get(u.blockchain)+1);\r\n            finalBlockChain.put(u.blockchain, 1);\r\n        }\r\n        Optional<Map.Entry<BlockChain, Integer>>maxEntry = finalBlockChain.entrySet().stream().max(Map.Entry.comparingByValue());\r\n\r\n        if(maxEntry.isPresent())\r\n            return maxEntry.get().getKey();\r\n        else{\r\n            this.blockchain=new BlockChain();\r\n            return this.blockchain;\r\n        }\r\n\r\n        //throw new WrongMethodTypeException(\"Update BlockChain maxEntry is not present\");\r\n    }\r\n\r\n    //get last block\r\n    public Block getLastBlock() {\r\n        //update blockchain?\r\n        if (blockchain.chain.size() == 0) {\r\n            blockchain.chain.add(new Block());\r\n            return blockchain.chain.get(0);\r\n        }\r\n        return blockchain.chain.get(blockchain.chain.size() - 1);\r\n    }\r\n\r\n\r\n    //sign the transaction\r\n    public String signTransaction(Transaction transaction) throws Exception {\r\n        //RSA signature\r\n\r\n        transaction.signature = RSA.sign(transaction.mess, this.privateKey);\r\n        return transaction.signature;\r\n    }\r\n\r\n    public void verifyBlock(Block block) throws Exception{\r\n        Map<String, Transaction> tmp=new LinkedHashMap<>(block.token.transactions);\r\n       // tmp=tmp.entrySet().stream().sorted(Map.Entry.comparingByValue(new ComparatorTransaction()))\r\n                //.collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2, LinkedHashMap::new));\r\n            tmp.forEach((key, value) -> {\r\n            try {\r\n                if (verifyTransaction(key, value.mess, value.sender.publicKey))\r\n                    block.token.transactions.get(key).verified=true;\r\n                else\r\n                    block.token.transactions.remove(key);\r\n\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n            }\r\n\r\n        });\r\n        block.proofOfWork(this.blockchain.difficulty);\r\n\r\n    }\r\n\r\n    //verify a transaction\r\n    public boolean verifyTransaction(String signature, String mess, PublicKey publicKey) throws Exception {\r\n        //proveri dali ima pari\r\n        Double amount=amountForUser(publicKey);\r\n        Double price=Double.parseDouble(mess.split(\";\")[0]);\r\n        System.out.println(amount+\" - \"+price);\r\n        if(amount-price<0)\r\n        {\r\n            System.out.println(price);\r\n            return false;}\r\n\r\n        return RSA.verify(mess, signature, publicKey);\r\n    }\r\n\r\n    //sum amount of coins for user with public key (+coinbase+receiver-sender)\r\n    public Double amountForUser(PublicKey publicKey) {\r\n        double sum = 0;\r\n        //iterates through blocks in chain\r\n        for (Block b : this.blockchain.chain) {\r\n            //sums the new coins of user\r\n            if (b.coinbase.coinbase.containsKey(publicKey))\r\n                sum += b.coinbase.coinbase.get(publicKey);\r\n\r\n            for (Transaction t : b.token.transactions.values()) {\r\n                if(t.verified) {\r\n                    //adds amount of transaction if the user is the receiver\r\n                    if (t.receiver.publicKey.equals(publicKey))\r\n                        sum += t.amount;\r\n                    //subtracts amount of transaction if the user is the sender\r\n                    if (t.sender.publicKey.equals(publicKey))\r\n                        sum -= t.amount;\r\n                }\r\n            }\r\n\r\n        }\r\n        return sum;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- blockchain_1/src/User.java	(revision 36b684aaa862b4495f359a4dc221d6a8a9c2eb71)
+++ blockchain_1/src/User.java	(date 1612651554172)
@@ -142,7 +142,7 @@
         //proveri dali ima pari
         Double amount=amountForUser(publicKey);
         Double price=Double.parseDouble(mess.split(";")[0]);
-        System.out.println(amount+" - "+price);
+        //System.out.println(amount+" - "+price);
         if(amount-price<0)
         {
             System.out.println(price);
Index: blockchain_1/src/WebMock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javax.xml.crypto.Data;\r\nimport java.lang.invoke.WrongMethodTypeException;\r\nimport java.util.*;\r\n\r\npublic class WebMock {\r\n\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        User sender = new User();\r\n        User receiver = new User();\r\n        User miner = new User();\r\n        User miner2 = new User();\r\n\r\n        DataHolder.addUser(sender);\r\n        DataHolder.addUser(receiver);\r\n        DataHolder.addUser(miner);\r\n        DataHolder.addUser(miner2);\r\n        sender.setUsers(DataHolder.users);\r\n        receiver.setUsers(DataHolder.users);\r\n        miner.setUsers(DataHolder.users);\r\n        miner2.setUsers(DataHolder.users);\r\n\r\n\r\n        miner.newCoinbase(Double.parseDouble(\"300.0\"), sender.publicKey);\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"100.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"1550.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"1560.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"50.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"10.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"15.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"10.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"107.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"17.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"18.0\"));\r\n        miner.verifyBlock(miner.getLastBlock());\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"1000.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"199.0\"));\r\n        sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble(\"60.0\"));\r\n\r\n        miner.updateBlockChainLocal();\r\n        miner.verifyBlock(miner.getLastBlock());\r\n        System.out.println(miner.blockchain.chain.get(0).toString());\r\n        System.out.println(miner.blockchain.chain.get(1).toString());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n  /*  public static BlockChain updateBlockChain(User user) {\r\n        //ako ova raboti dzver\r\n        HashMap<BlockChain, Integer> finalBlockChain = new HashMap<>();\r\n        for(User u : DataHolder.getUsers()){\r\n            if(finalBlockChain.containsKey(u.blockchain))\r\n                finalBlockChain.put(u.blockchain, finalBlockChain.get(u.blockchain)+1);\r\n            finalBlockChain.put(u.blockchain, 1);\r\n        }\r\n        Optional<Map.Entry<BlockChain, Integer>>maxEntry = finalBlockChain.entrySet().stream().max(Map.Entry.comparingByValue());\r\n        if(maxEntry.isPresent())\r\n            return maxEntry.get().getKey();\r\n        else throw new WrongMethodTypeException(\"Update BlockChain maxEntry is not present\");\r\n    }\r\n\r\n*/\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- blockchain_1/src/WebMock.java	(revision 36b684aaa862b4495f359a4dc221d6a8a9c2eb71)
+++ blockchain_1/src/WebMock.java	(date 1612650662272)
@@ -37,10 +37,17 @@
         sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble("199.0"));
         sender.newTransaction(sender.publicKey, receiver.publicKey, Double.parseDouble("60.0"));
 
+
         miner.updateBlockChainLocal();
         miner.verifyBlock(miner.getLastBlock());
-        System.out.println(miner.blockchain.chain.get(0).toString());
-        System.out.println(miner.blockchain.chain.get(1).toString());
+        //System.out.println(miner.blockchain.chain.get(0).toString());
+        //System.out.println(miner.blockchain.chain.get(1).toString());
+        for(Block b: miner.blockchain.chain)
+        {
+            System.out.println(b.toString());
+        }
+
+
 
 
 
